use crate::config::{Config, Enum, Ty, TyDecl, TypeScriptEnumType};

use super::{ConfigProvider, Output};

struct TypesOutput<'src> {
	config: &'src Config<'src>,
	tabs: u32,
	buf: String,
}

impl<'src> Output<'src> for TypesOutput<'src> {
	fn push(&mut self, s: &str) {
		self.buf.push_str(s);
	}

	fn indent(&mut self) {
		self.tabs += 1;
	}

	fn dedent(&mut self) {
		self.tabs -= 1;
	}

	fn push_indent(&mut self) {
		for _ in 0..self.tabs {
			self.push("\t");
		}
	}
}

impl<'src> ConfigProvider<'src> for TypesOutput<'src> {
	fn get_config(&self) -> &'src Config<'src> {
		self.config
	}
}

impl<'src> TypesOutput<'src> {
	pub fn new(config: &'src Config<'src>) -> Self {
		Self {
			config,
			tabs: 0,
			buf: String::new(),
		}
	}

	fn push_tydecl(&mut self, tydecl: &TyDecl) {
		let ty = &*tydecl.ty.borrow();

		let mut depth = 0usize;
		for name in &tydecl.path {
			depth += 1;
			self.push_indent();
			self.push("export ");
			if depth == 1 {
				self.push("declare ");
			}
			self.push(&format!("namespace {name} {{\n"));
			self.indent();
		}
		self.push_indent();
		self.push("export ");

		if let Ty::Enum(Enum::Unit(variants)) = ty {
			match self.get_config().typescript_enum {
				TypeScriptEnumType::StringLiteral => self.push(&format!(
					"type {} = {};\n",
					tydecl.name,
					&variants
						.iter()
						.map(|v| format!("\"{v}\""))
						.collect::<Vec<_>>()
						.join(" | ")
				)),
				TypeScriptEnumType::ConstString => {
					self.push(&format!("const enum {} {{\n", tydecl.name));
					self.indent();

					for variant in variants {
						self.push_line(&format!("{variant} = \"{variant}\","));
					}

					self.dedent();
					self.push_line("}");
				}
				TypeScriptEnumType::ConstNumber => {
					self.push(&format!("const enum {} {{\n", tydecl.name));
					self.indent();

					for variant in variants {
						self.push_line(&format!("{variant},"));
					}

					self.dedent();
					self.push_line("}");
				}
			}
		} else {
			self.push(&format!("type {} = ", tydecl.name));
			self.push_ty(ty);
			self.push(";\n");
		}

		for _ in 0..depth {
			self.dedent();
			self.push_line("}");
		}
	}

	fn push_tydecls(&mut self) {
		for tydecl in self.config.tydecls.iter() {
			self.push_tydecl(tydecl);
		}
	}

	pub fn output(mut self) -> String {
		self.push_line(&format!(
			"// Types generated by Zap v{} (https://github.com/red-blox/zap)",
			env!("CARGO_PKG_VERSION")
		));

		self.push_tydecls();

		self.buf
	}
}

pub fn code<'src>(config: &'src Config<'src>) -> Option<String> {
	if !config.typescript {
		return None;
	}

	Some(TypesOutput::new(config).output())
}
